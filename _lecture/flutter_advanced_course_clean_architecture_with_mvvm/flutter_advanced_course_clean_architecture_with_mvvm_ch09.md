---
layout: default
title: CH 9 Presentation Layer - State Renderer
parent: Flutter Advanced Course - Clean Architecture With MVVM
nav_order: 9
---

<br>

## 앱 내에서 HTTP 통신시 발생하는 이슈
HTTP 로 통신할 경우 보안상 위험하기 때문에 iOS, Android 모두 설정에서 허용 절차를 거쳐 줘야한다. 앱 심사시 보안 항목에서 HTTP 통신 여부를 확인하고 있으므로
가장 좋은 방법은 애초에 앱 내애서 HTTP 통신할 일이 없도록 하는 것이다.

강의에서는 baseUrl 에서 HTTP 통신을 하도록 설정했기 때문에 설정 수정이 필요했다. chatgpt 피셜로 해당 사항에 관한 내용은 아래와 같았다.

> 앱스토어와 구글 플레이 심사 과정에서는 보안과 관련된 검사가 이루어지며, 앱이 http 또는 https 프로토콜을 사용하는지 여부를 확인합니다.
> 이를 위해 네트워크 패킷을 캡처해서 검사하거나, 앱의 코드나 설정 파일 등을 검토하여 http 또는 https 사용 여부를 파악할 수 있습니다.
> 따라서, 앱을 개발할 때는 http 통신보다는 https 통신을 사용하고, info.plist나 AndroidManifest.xml과 같은 설정 파일에서도 http 사용을 금지하도록 설정하는 것이 좋습니다.
> 이렇게 하면 보안 문제를 예방할 수 있으며, 앱스토어와 구글 플레이에서의 심사도 원활하게 통과할 수 있습니다.

일단 이러한 이슈가 있고, HTTP 통신 사용할 경우 심사에 불리하고 따로 설정이 필요하다는 사실만 인지하고 넘어간다.

<br>

## ~screen 내 state 에 따른 rendering 방식 및 전략

당연한 이야기이지만 사용자가 앱을 사용할때 무조건 상호작용이 발생한다. 그리고 사용자의 행위가 발생한 시점과 이에 대해 사용자가 기대하는 앱의 응답이 발생하는 시점 사이에는 0.0001초이든 10초이든 무조건 시간적인 갭이 존재한다.

그 갭이 무조건, 항상, 예외없이 '사람이 느낄 수 없을 정도로 짧은 시간'이라면 화면에서 별다른 처리를 해주지 않아도 괜찮겠지만 상황에 따라 꽤 오래 시간이 걸리는데도 아무런 처리를 해주지 않으면 사용자는 당황할 것이다.
예를 들어 로그인이 2초 정도 걸린다고 했을때, 사용자가 아이디와 비밀번호를 입력한 후 로그인을 눌렀고 실제로 로딩 요청이 발생했다고 해도 사용자가 이를 인지하지 못하면 '왜 로그인이 안되지?' 라고 의아해 하다가 갑자기 로그인이 되고
화면 전환이 이뤄질 것이다. 이는 적절한 UX 가 아니다.

위 예시로 든 것은 결국 '사용자가 입력한 것이 정상적으로 요청 되었고 앱은 그 요청을 수행중이다.' 라는 의미를 전달할 처리가 필요하다는 것이다.
이것은 단지 '처리가 오래 걸릴때'의 상황에서는 '로딩' 중 임을 알려줄 수 있는 여러가지 처리가 필요한 예시이고 이 외에도 '요청 중 에러가 발생' 했다던가 '요청이 성공적으로 처리 되었다던가' 하는 공통적인 상황이 있을 것이다.

이번 챕터에서는 그러한 공통적인 상황과 이에 대한 처리를 어떤식으로 하면 좋을지 clean architecture 관점에서 다뤘다.

enum 으로 state 를 규정하고 baseViewModel 을 만들어서 모든 viewModel 이 이를 상속하게 하여 이를 Stream 으로 처리하는 방식을 취했다.
핵심은 구체적으로 뭘 어떻게 처리를 했는지를 기억하는 것이 아니라고 생각이 들었고, 포인트만 인지하면 될 것 같다. 내가 생각한 포인트는 아래와 같다.

- BaseViewModel 에 state rendering 에 대한 처리를 정의하고 이를 모든 viewModel 이 상속하도록 하여 공통화 처리를 하였다.
- 결국 BaseViewModel 에 정의된 state 를 개별 viewModel 에서 조작하고, 개별 view 가 이를 Stream 으로 받아서 rendering 한다. 즉, view 에서의 rendering 은 react 일 뿐이고, 실질적인 제어는 viewModel 이 담당한다.

특히 두 번째 포인트가 가장 중요한 것 같다. 상태에 따른 처리의 제어권을 결국 view 가 갖게 하느냐, viewModel 이 갖게 하느냐의 여부인데 viewModel 이 가지도록 한 것이다.

전에 view, viewModel 간 Stream 을 통한 연동을 보면 아래와 같았는데, 여기서 viewModel 의 function 내에서 baseViewModel 의 state 를 컨트롤하고,
view 에서는 이를 stream 으로 받아 보여준다.

![](/images/concept_view_viewmodel.png)

결과적으로 하나의 function 내에서 state 를 변경 할 때마다 view 에서 이를 바로바로 rendering 처리 하게 되는 것이다.
예를 들어 로그인 function 이라면 아래와 같이 처리될 수 있다.

function() {<br>
- 상태 변경(로딩 스피너 띄움)
- 로그인 시도
- 로그인 종료 후 결과에 따른 처리  
  - 성공시 상태 변경(로딩 스피너 없앰)
  - 실패시 상태 변경(로딩 스피너 없애고 에러 다이얼로그 등 화면 표시)<br>

}

여기서 세부적인 처리가 어떻다 라기 보다는 하나의 function 내에서 상태 처리에 대한 state 를 상황에 맞게 처리하면서 즉시 stream 으로 view 로 전달하도록 한다는 것이 포인트다.
